<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test webgl</title>
    <style>
        body {
            font-family: Monospace;
            background: #000000;
            color: #fff;
            margin: 0px;
        }
        h3 {
            font-weight: normal;
        }
        #info {
            color: #fff;
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
        }
        #info a {
            color: #75ddc1;
            font-weight: bold;
        }
        
    </style>
</head>
<body>  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    
    
    <script type="module">
        import { OrbitControls } from 'https://unpkg.com/three@0.126.0/examples/jsm/controls/OrbitControls.js';
        import Stats from 'https://unpkg.com/three@0.126.0/examples/jsm/libs/stats.module.js';
        import { LightProbeGenerator } from 'https://unpkg.com/three@0.126.0/examples/jsm/lights/LightProbeGenerator.js';
        
        //===================================================== canvas
        var renderer = new THREE.WebGLRenderer({ alpha: true, antialiase: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        //===================================================== scene
        var scene = new THREE.Scene();
        
        //===================================================== camera
        var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 1.5;
        
        //===================================================== lights
        var light = new THREE.DirectionalLight(0xefefff, 3);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        
        //===================================================== resize
        window.addEventListener("resize", function() {
            let width = window.innerWidth;
            let height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
        
        const stats = new Stats();
        document.body.appendChild( stats.dom );
        
        //===================================================== model
        var loader = new THREE.GLTFLoader();
        var mixer;
        var model;
        loader.load(
        "./truc50k.glb", function(gltf) {
            
            gltf.scene.traverse( function( node ) {
                if ( node instanceof THREE.Mesh ) { 
                    node.castShadow = true; 
                    node.material.side = THREE.DoubleSide;
                }
            });
            
            
            model = gltf.scene;
            model.scale.set(1.5,1.5,1.5);
            scene.add(model);
            
            mixer = new THREE.AnimationMixer(model);
            mixer.clipAction(gltf.animations[1]).play();
        });
        for (let i = 0; i < 500; i++) {
            const geometry = new THREE.SphereGeometry( 0.05, 10, 10 );
            const material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
            const cube = new THREE.Mesh( geometry, material );
            cube.position.set(Math.random()*100-50 ,Math.random()*100-50 ,Math.random()*100-50 )
            scene.add( cube );
        }
        
        var clock = new THREE.Clock();
        function render() {
            requestAnimationFrame(render);
            var delta = clock.getDelta();
            if (mixer != null) mixer.update(delta);
            // if (model) model.rotation.y += 0.010;
            stats.update();
            
            renderer.render(scene, camera);
        }
        
        const controls = new OrbitControls( camera, renderer.domElement );
        controls.listenToKeyEvents( window ); // optional
        
        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
        
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        
        controls.screenSpacePanning = false;
        
        controls.minDistance = 1;
        controls.maxDistance = 50;
        
        controls.maxPolarAngle = Math.PI / 2;
        
        render();
        
    </script>
</body>
</html>
<!-- envmap
    const genCubeUrls = function ( prefix, postfix ) {
        
        return [
        prefix + 'px' + postfix, prefix + 'nx' + postfix,
        prefix + 'py' + postfix, prefix + 'ny' + postfix,
        prefix + 'pz' + postfix, prefix + 'nz' + postfix
        ];
        
    };
    
    const urls = genCubeUrls( './texture/dark-s_', '.jpg' );
    
    new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {
        
        cubeTexture.colorSpace = THREE.SRGBColorSpace;
        
        scene.background = cubeTexture;
        
        lightProbe.copy( LightProbeGenerator.fromCubeTexture( cubeTexture ) );
        
        const geometry = new THREE.SphereGeometry( 5, 64, 32 );
        //const geometry = new THREE.TorusKnotGeometry( 4, 1.5, 256, 32, 2, 3 );
        
        const material = new THREE.MeshStandardMaterial( {
            color: 0xffffff,
            metalness: 0,
            roughness: 0,
            envMap: cubeTexture,
            envMapIntensity: API.envMapIntensity,
        } );
        
        // mesh
        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );
        render();
        
    } ); -->
    